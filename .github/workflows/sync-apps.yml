name: Sync Apps from Upstream Sources

on:
  schedule:
    # Runs daily at 06:00 UTC
    - cron: '0 6 * * *'
  workflow_dispatch:
    # Allow manual trigger from Actions tab

permissions:
  contents: write

jobs:
  sync:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Sync apps from upstream sources
        run: |
          cat > sync.mjs << 'SCRIPT'
          import { readFileSync, writeFileSync } from 'fs';

          // Upstream sources and which apps to pull from each
          const SOURCES = [
            {
              url: 'https://raw.githubusercontent.com/dvntm0/AltStore/refs/heads/main/repo.json',
              apps: [
                'com.google.ios.youtube',       // YouTube Plus
                'com.google.ios.youtubemusic',  // YouTube Music Ultimate
                'com.firecore.infuse',          // Infuse Plus
                'com.facebook.Facebook',        // Glow for Facebook
                'com.facebook.Messenger'        // Flow for Messenger
              ]
            },
            {
              url: 'https://raw.githubusercontent.com/YTLitePlus/YTLitePlus-Altstore/main/apps.json',
              apps: [
                'com.google.ios.youtube'        // YTLitePlus (remapped below)
              ],
              // Remap bundle ID to avoid conflict with YouTube Plus from dvntm0
              remap: {
                'com.google.ios.youtube': 'com.google.ios.youtube.ytliteplus'
              }
            },
            {
              url: 'https://raw.githubusercontent.com/miyukowo/AltStore/refs/heads/main/repo.json',
              apps: [
                // Add your self-hosted app bundle IDs here as you add them to miyukowo/AltStore
                // e.g. 'com.example.myapp'
              ]
            }
          ];

          async function fetchJSON(url) {
            const res = await fetch(url);
            if (!res.ok) throw new Error(`Failed to fetch ${url}: ${res.status}`);
            return res.json();
          }

          function normalizeApp(app, remap) {
            // Normalize to our standard format
            const bundleId = remap?.[app.bundleIdentifier] || app.bundleIdentifier;
            
            // Normalize screenshots field name (some use 'screenshots', others 'screenshotURLs')
            const screenshots = app.screenshotURLs || app.screenshots || [];
            
            // Normalize versions
            let versions = app.versions || [];
            if (versions.length === 0 && app.version) {
              // Some sources use flat version fields instead of versions array
              versions = [{
                version: app.version,
                date: app.versionDate || app.date || '',
                size: app.size || 0,
                downloadURL: app.downloadURL || '',
                localizedDescription: app.versionDescription || ''
              }];
            }

            // Normalize version dates to YYYY-MM-DD
            versions = versions.map(v => ({
              ...v,
              date: v.date ? v.date.split('T')[0] : ''
            }));

            const result = {
              name: app.name,
              bundleIdentifier: bundleId,
              developerName: app.developerName,
              subtitle: app.subtitle || '',
              localizedDescription: app.localizedDescription || '',
              iconURL: app.iconURL || '',
              tintColor: (app.tintColor || '').replace('#', ''),
              screenshotURLs: screenshots,
              versions
            };

            // Preserve appPermissions if present
            if (app.appPermissions) {
              result.appPermissions = app.appPermissions;
            }

            return result;
          }

          function generateNewsFromApp(app) {
            // Generate news items from version updates
            if (!app.versions || app.versions.length === 0) return [];

            const latest = app.versions[0];
            return [{
              title: `${app.name} v${latest.version} Released`,
              identifier: `${app.bundleIdentifier}-${latest.version}`.replace(/\./g, '-'),
              caption: latest.localizedDescription
                ? latest.localizedDescription.split('\n').filter(l => l.trim()).slice(0, 2).join(' ')
                : `${app.name} has been updated to version ${latest.version}.`,
              date: latest.date || '',
              tintColor: (app.tintColor || '').replace('#', ''),
              appID: app.bundleIdentifier,
              notify: false
            }];
          }

          async function main() {
            // Load current apps.json to preserve repo metadata and version history
            const local = JSON.parse(readFileSync('apps.json', 'utf8'));
            const updatedApps = [];
            const allNews = [];

            // Build a lookup of existing versions keyed by bundleIdentifier
            const existingVersionsMap = new Map();
            (local.apps || []).forEach(app => {
              existingVersionsMap.set(app.bundleIdentifier, app.versions || []);
            });

            for (const source of SOURCES) {
              console.log(`Fetching: ${source.url}`);
              const data = await fetchJSON(source.url);
              const apps = data.apps || [];

              // If source.apps is empty, fetch ALL apps from that source; otherwise filter by listed IDs
              const appsToProcess = source.apps.length > 0
                ? source.apps.map(id => apps.find(a => a.bundleIdentifier === id)).filter(Boolean)
                : apps;

              for (const app of appsToProcess) {
                if (!app) continue;
                const normalized = normalizeApp(app, source.remap);

                // Merge version history: prepend any versions not already stored
                const existingVersions = existingVersionsMap.get(normalized.bundleIdentifier) || [];
                const existingVersionStrings = new Set(existingVersions.map(v => v.version));
                const newVersions = normalized.versions.filter(v => !existingVersionStrings.has(v.version));
                if (newVersions.length > 0) {
                  console.log(`  + ${newVersions.length} new version(s) for ${normalized.name}`);
                }
                normalized.versions = [...newVersions, ...existingVersions];

                console.log(`  âœ“ ${normalized.name} (${normalized.bundleIdentifier}) â€” ${normalized.versions.length} version(s) total`);
                updatedApps.push(normalized);
                // Generate news from latest version
                const news = generateNewsFromApp(normalized);
                allNews.push(...news);
              }

              // Also sync any top-level news from the source
              if (data.news && Array.isArray(data.news)) {
                console.log(`  ðŸ“° Found ${data.news.length} news items from source`);
                allNews.push(...data.news);
              }
            }

            if (updatedApps.length > 0) {
              local.apps = updatedApps;

              // Deduplicate news by identifier
              const newsMap = new Map();
              allNews.forEach(item => {
                if (item.identifier && !newsMap.has(item.identifier)) {
                  newsMap.set(item.identifier, item);
                }
              });
              local.news = Array.from(newsMap.values())
                .filter(item => {
                  if (!item.date) return true;
                  const sixMonthsAgo = new Date();
                  sixMonthsAgo.setMonth(sixMonthsAgo.getMonth() - 6);
                  return new Date(item.date) >= sixMonthsAgo;
                })
                .sort((a, b) => new Date(b.date) - new Date(a.date));

              writeFileSync('apps.json', JSON.stringify(local, null, 2) + '\n');
              console.log(`\nUpdated apps.json with ${updatedApps.length} apps and ${local.news.length} news items`);
            } else {
              console.log('\nNo apps found, skipping update');
            }
          }

          main().catch(err => {
            console.error(err);
            process.exit(1);
          });
          SCRIPT

          node sync.mjs

      - name: Check for changes
        id: diff
        run: |
          git diff --quiet apps.json && echo "changed=false" >> $GITHUB_OUTPUT || echo "changed=true" >> $GITHUB_OUTPUT

      - name: Commit and push
        if: steps.diff.outputs.changed == 'true'
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git add apps.json
          git commit -m "chore: auto-sync apps from upstream sources"
          git push
